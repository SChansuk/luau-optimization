{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#preface","title":"Preface","text":"<p>This document is intended for intermediate Roblox developers (     i.e. those who have a basic understanding of Roblox Studio API and Luau) who want to improve the performance of their games.</p> <p>This book contains guidelines and advices on how to write efficient software using the Luau language. Software correctness and maintainability are taken into account,  but are not the primary concerns of the guidelines. The guidelines are focused on performance and efficiency.</p>"},{"location":"introduction/","title":"Introduction to Optimization","text":"<p>One of the main reasons for preferring Luau over simpler, higher-level scripting languages is that Luau allows for the  development of complex Roblox games with an efficient use of hardware resources. The language itself doesn't guarantee  efficient code automatically, but it provides a robust set of features that aid developers in achieving performance gains. </p> <p>Sloppy Luau code may be no more efficient than higher-level implementations of the same algorithms,  but a skilled Luau programmer with in-depth knowledge of the language can write software that is efficient  from the start and further optimize it as needed. </p> <p>This guide offers techniques for writing efficient Luau code and optimizing existing game scripts.  Often, there is no single solution to a performance problem that is optimal for all scenarios.  Therefore, optimization typically involves incrementally refactoring code to improve performance,   bringing it closer to the best possible outcome.</p> <p>Effective optimization requires that the codebase is modular enough to isolate performance-critical sections.  With well-structured code, you can then use various tools, libraries, and strategies to enhance these parts,  thereby boosting the overall execution speed of your game. While modern game engines and platforms  like Roblox perform many optimizations automatically, there are still higher-level optimizations that developers must address.  This guide focuses on those optimizations that current engines and compilers cannot (yet) achieve.</p> <p>Most of the optimization techniques discussed are platform-independent, so there will be minimal references to specific operating systems, hardware, or Roblox Studio versions. However, some techniques might be more effective or applicable depending on the specific combinations of platform, hardware, and version of Roblox Studio you are using.</p>"},{"location":"optimization-lifecycle/","title":"Optimization lifecycle","text":"<p>The construction of an efficient software, or rather game should adhere to the following development process:</p> <p>Design: Firstly, the algorithms and data structures are designed in a way that makes sense for the application logic and that is reasonably efficient, but without considering optimization.  When designing a widely used data structure where the optimal implementation is not obvious (for example, whether to use an array or a linked list), an abstract structure is defined for which the implementation may be changed at the optimization stage.</p> <p>Implementation: Secondly, the code that implements the designed algorithms is written, following guidelines to avoid inefficient operations and encapsulating operations that are likely to require optimization.</p> <p>Functional Testing: The resulting software is then tested to increase the probability that it doesn't have crippling defects.</p> <p>Optimization (aka Tuning): After having completed the development of a correctly working application, the optimization stage begins,  with the following sub-stages:</p> <ol> <li>Performance Testing: Commands with inadequate performance are detected. These are commands that, when processing typical data, require more resources (CPU time, storage space, etc.) than are available.</li> <li>Profiling (aka Performance Analysis): For every command with inadequate performance, a profiler is used to determine which portions of code are the so-called bottlenecks for that command. Bottlenecks are parts of code where a disproportionate amount of time is spent or memory space is allocated.</li> <li>Algorithmic Optimization: For each bottleneck, optimization techniques are applied that are largely independent of the programming language and totally independent of the platform. Such techniques can be found in algorithm theory textbooks. This optimization involves attempting to reduce the number of executed machine cycles.  In particular, it involves reducing the number of calls to costly routines or transforming expensive operations into equivalent but less costly operations. For example, the quicksort sorting algorithm is chosen instead of the selection sort algorithm. If this makes the program fast enough, the optimization stage is complete.</li> </ol> <p>This development process follows two criteria:</p> <ul> <li>Principle of Diminishing Returns: Optimizations that yield big results with little effort should be applied first, as this minimizes the time needed to reach the performance goals.</li> <li>Principle of Diminishing Portability: It is better to apply optimizations applicable to several platforms first, as they remain applicable on changing platforms and are more understandable to other programmers.</li> </ul> <p>This stage sequence is not meant to be a one-way sequence, in which once one stage is reached, the preceding stage is no longer used. In fact, every stage may succeed or fail. If a stage succeeds, the next stage is applied, while if a stage fails, the previous stage is repeated, in a sort of backtracking algorithm.</p> <p>In addition, a partial performance test should be performed after every optimization attempt, just to check whether the attempt was useful and, if so, to check whether more optimizations are needed.</p> <p>Finally, after having completed the optimization, both the functional testing and the complete performance testing must be repeated to guarantee that the newly optimized version of the software is still functionally correct and has suitable performance.</p>"}]}